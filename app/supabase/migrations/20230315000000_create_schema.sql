-- noinspection SqlNoDataSourceInspectionForFile
-- noinspection SqlResolveForFile @ any/"auth"
-- we need the field email_confirmed_at to insert users with confirmed email
-- but the field is only inserted with the gotrue migrations
-- see https://github.com/supabase/gotrue/blob/3b77d62d71ad810697273a518a48bb0b539be4e6/migrations/20210710035447_alter_users.up.sql#L10,L18
ALTER TABLE auth."users"
ADD COLUMN IF NOT EXISTS "email_confirmed_at" TIMESTAMP WITH TIME ZONE;

-- we need the field email_change_token_new to insert users
-- but the field is only inserted with the gotrue migrations
-- see https://github.com/supabase/gotrue/blob/0f8548fee9471fcfada0744f41ffa151b7e1731d/migrations/20210730183235_add_email_change_confirmed.up.sql#L7,L15
ALTER TABLE auth."users"
ADD COLUMN IF NOT EXISTS "email_change_token_new" VARCHAR;

-- we need the table identities to insert users
-- but the table is only inserted with the gotrue migrations
-- see https://github.com/supabase/gotrue/blob/0f8548fee9471fcfada0744f41ffa151b7e1731d/migrations/20210909172000_create_identities_table.up.sql
CREATE TABLE IF NOT EXISTS
  auth.identities (
    id TEXT NOT NULL,
    user_id UUID NOT NULL,
    identity_data JSONB NOT NULL,
    provider TEXT NOT NULL,
    last_sign_in_at timestamptz NULL,
    created_at timestamptz NULL,
    updated_at timestamptz NULL,
    CONSTRAINT identities_pkey PRIMARY KEY (provider, id),
    CONSTRAINT identities_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users (id) ON DELETE CASCADE
  );

COMMENT ON TABLE auth.identities IS 'Auth: Stores identities associated to a user.';

ALTER TABLE auth.identities OWNER TO supabase_auth_admin;

/**
the function auth.jwt is only inserted with the gotrue migrations
https://github.com/supabase/gotrue/blob/0f8548fee9471fcfada0744f41ffa151b7e1731d/migrations/20220531120530_add_auth_jwt_function.up.sql#L1
*/
CREATE
OR REPLACE FUNCTION auth.jwt () RETURNS jsonb STABLE LANGUAGE SQL AS $$
select
    coalesce(
            nullif(current_setting('request.jwt.claim', true), ''),
            nullif(current_setting('request.jwt.claims', true), '')
        )::jsonb
$$;

ALTER FUNCTION auth.jwt () OWNER TO supabase_auth_admin;

GRANT
EXECUTE ON FUNCTION auth.jwt () TO postgres;

GRANT
EXECUTE ON FUNCTION auth.jwt () TO dashboard_user;

/**
end function auth.jwt()


*/
CREATE EXTENSION IF NOT EXISTS "uuid-ossp"
WITH
  SCHEMA extensions;

CREATE
OR REPLACE PROCEDURE auth.sce_create_user (user_email TEXT) AS $$
DECLARE
    generated_user_id            uuid    := extensions.uuid_generate_v4();
    -- "password"
    hardcoded_password_encrypted VARCHAR := '$2a$10$zxJtm53nPMd7PRrShiaqGeEyQANG8sKMvGKvRU5eWJgkwHbeODr2C';
BEGIN
    INSERT INTO auth.users (instance_id, id, aud, role, email, email_confirmed_at, encrypted_password,
                            confirmation_token,
                            raw_app_meta_data,
                            raw_user_meta_data, is_super_admin, created_at, updated_at, email_change,
                            email_change_token_new, recovery_token)
    VALUES ('00000000-0000-0000-0000-000000000000', generated_user_id, 'authenticated',
            'authenticated', user_email, now(), hardcoded_password_encrypted, '', '{
        "provider": "email",
        "providers": [
          "email"
        ]
      }', '{}', null, now(), now(), '', '', '');


    INSERT INTO auth.identities (id, user_id, identity_data, provider, created_at, updated_at)
    VALUES (generated_user_id, generated_user_id,
            '{
              "sub": "",
              "email": ""
            }',
            'email', now(), now());

    -- becuase inserting concatenated json made problem, we do it like this
    UPDATE auth.identities
    SET identity_data = jsonb_set(identity_data, '{sub}', (SELECT '"' || generated_user_id || '"')::jsonb)
    WHERE user_id = generated_user_id;

    UPDATE auth.identities
    SET identity_data = jsonb_set(identity_data, '{email}', (SELECT '"' || user_email || '"')::jsonb)
    WHERE user_id = generated_user_id;

END;
$$ LANGUAGE plpgsql;

CREATE TABLE
  products (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    title TEXT,
    description TEXT,
    rarity VARCHAR(30),
    SET
      TEXT,
      card_type VARCHAR(30),
      attributes VARCHAR(100),
      TYPES VARCHAR(100),
      price FLOAT,
      created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone ('utc'::TEXT, NOW()) NOT NULL
  );

ALTER TABLE products ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Logged in users can create products." ON products FOR INSERT
WITH
  CHECK (TRUE);

CREATE POLICY "Logged in users can update products." ON products
FOR UPDATE
  USING (TRUE);

CREATE POLICY "Logged in users can delete products." ON products FOR DELETE USING (TRUE);

CREATE POLICY "products are public." ON products FOR
SELECT
  USING (TRUE);

CREATE TABLE
  payment (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    payment_amount FLOAT NOT NULL,
    payment_type VARCHAR(30)
  );

ALTER TABLE payment ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Logged in users can create payments." ON payment FOR INSERT
WITH
  CHECK (TRUE);

CREATE POLICY "Logged in users can update payments" ON payment
FOR UPDATE
  USING (TRUE);

CREATE POLICY "Logged in users can delete payments." ON payment FOR DELETE USING (TRUE);

CREATE POLICY "payments are public." ON payment FOR
SELECT
  USING (TRUE);

CREATE TABLE
  addresses (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    firstname TEXT NOT NULL,
    NAME TEXT NOT NULL,
    company TEXT,
    "address" TEXT NOT NULL,
    zip_code TEXT NOT NULL,
    city TEXT NOT NULL
  );

ALTER TABLE addresses ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Everyone can create addresses" ON addresses FOR INSERT
WITH
  CHECK (TRUE);

CREATE POLICY "Logged in admins can update addresses" ON addresses
FOR UPDATE
  USING (TRUE);

CREATE POLICY "Logged in admins can delete addresses" ON addresses FOR DELETE USING (TRUE);

CREATE POLICY "Logged in admins can read addresses" ON addresses FOR
SELECT
  USING (TRUE);

CREATE TABLE
  customer (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    email TEXT NOT NULL,
    user_id UUID NULL REFERENCES auth.users (id) ON DELETE SET NULL ON UPDATE CASCADE,
    shipping_address_id BIGINT REFERENCES addresses (id) NOT NULL,
    billing_address_id BIGINT REFERENCES addresses (id) NOT NULL
  );

ALTER TABLE customer ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Anonymous users can create customers with user_id null" ON customer FOR INSERT TO anon
WITH
  CHECK (user_id IS NULL);

CREATE POLICY "Logged in users can create customers with their own user id" ON customer FOR INSERT TO authenticated
WITH
  CHECK (user_id = (auth.jwt () ->> 'sub')::UUID);

CREATE POLICY "Logged in admins can update customer data" ON customer
FOR UPDATE
  USING (TRUE);

CREATE POLICY "Logged in admins can delete customer accounts" ON customer FOR DELETE USING (TRUE);

CREATE POLICY "Logged in admins can read customer orders" ON customer FOR
SELECT
  USING (TRUE);

CREATE TABLE
  orders (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    order_state VARCHAR(30),
    payment_id BIGINT REFERENCES payment (id),
    customer_id BIGINT REFERENCES customer (id),
    notification_sent BOOLEAN DEFAULT FALSE
  );

ALTER TABLE orders ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Everyone can create orders." ON orders FOR INSERT
WITH
  CHECK (TRUE);

CREATE POLICY "Logged in users can update orders." ON orders
FOR UPDATE
  USING (TRUE);

CREATE POLICY "Logged in users can delete orders." ON orders FOR DELETE USING (TRUE);

CREATE POLICY "orders are public." ON orders FOR
SELECT
  USING (TRUE);

CREATE TABLE
  orderitem (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    order_id BIGINT REFERENCES orders (id),
    product_id BIGINT REFERENCES products (id),
    quantity INT DEFAULT 1
  );

ALTER TABLE orderitem ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Everyone can create orderitems." ON orderitem FOR INSERT
WITH
  CHECK (TRUE);

CREATE POLICY "Logged in users can update orderitems" ON orderitem
FOR UPDATE
  USING (TRUE);

CREATE POLICY "Logged in users can delete orderitems." ON orderitem FOR DELETE USING (TRUE);

CREATE POLICY "orderitems are public." ON orderitem FOR
SELECT
  USING (TRUE);
