-- noinspection SqlNoDataSourceInspectionForFile
-- noinspection SqlResolveForFile @ any/"auth"

-- we need the field email_confirmed_at to insert users with confirmed email
-- but the field is only inserted with the gotrue migrations
-- see https://github.com/supabase/gotrue/blob/3b77d62d71ad810697273a518a48bb0b539be4e6/migrations/20210710035447_alter_users.up.sql#L10,L18
ALTER TABLE auth."users"
    ADD COLUMN IF NOT EXISTS "email_confirmed_at" TIMESTAMP WITH TIME ZONE;

-- we need the field email_change_token_new to insert users
-- but the field is only inserted with the gotrue migrations
-- see https://github.com/supabase/gotrue/blob/0f8548fee9471fcfada0744f41ffa151b7e1731d/migrations/20210730183235_add_email_change_confirmed.up.sql#L7,L15
ALTER TABLE auth."users"
    ADD COLUMN IF NOT EXISTS "email_change_token_new" VARCHAR;

-- we need the table identities to insert users
-- but the table is only inserted with the gotrue migrations
-- see https://github.com/supabase/gotrue/blob/0f8548fee9471fcfada0744f41ffa151b7e1731d/migrations/20210909172000_create_identities_table.up.sql
CREATE TABLE IF NOT EXISTS auth.identities
(
    id              text        NOT NULL,
    user_id         uuid        NOT NULL,
    identity_data   JSONB       NOT NULL,
    provider        text        NOT NULL,
    last_sign_in_at timestamptz NULL,
    created_at      timestamptz NULL,
    updated_at      timestamptz NULL,
    CONSTRAINT identities_pkey PRIMARY KEY (provider, id),
    CONSTRAINT identities_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users (id) ON DELETE CASCADE
);
COMMENT ON TABLE auth.identities is 'Auth: Stores identities associated to a user.';

alter table auth.identities
    owner to supabase_auth_admin;


CREATE EXTENSION IF NOT EXISTS "uuid-ossp" WITH SCHEMA extensions;

CREATE OR REPLACE PROCEDURE auth.sce_create_user(user_email TEXT) AS
$$
DECLARE
    generated_user_id            uuid    := extensions.uuid_generate_v4();
    -- "password"
    hardcoded_password_encrypted VARCHAR := '$2a$10$zxJtm53nPMd7PRrShiaqGeEyQANG8sKMvGKvRU5eWJgkwHbeODr2C';
BEGIN
    INSERT INTO auth.users (instance_id, id, aud, role, email, email_confirmed_at, encrypted_password,
                            confirmation_token,
                            raw_app_meta_data,
                            raw_user_meta_data, is_super_admin, created_at, updated_at, email_change,
                            email_change_token_new, recovery_token)
    VALUES ('00000000-0000-0000-0000-000000000000', generated_user_id, 'authenticated',
            'authenticated', user_email, now(), hardcoded_password_encrypted, '', '{
        "provider": "email",
        "providers": [
          "email"
        ]
      }', '{}', null, now(), now(), '', '', '');


    INSERT INTO auth.identities (id, user_id, identity_data, provider, created_at, updated_at)
    VALUES (generated_user_id, generated_user_id,
            '{
              "sub": "",
              "email": ""
            }',
            'email', now(), now());

    -- becuase inserting concatenated json made problem, we do it like this
    UPDATE auth.identities
    SET identity_data = jsonb_set(identity_data, '{sub}', (SELECT '"' || generated_user_id || '"')::jsonb)
    WHERE user_id = generated_user_id;

    UPDATE auth.identities
    SET identity_data = jsonb_set(identity_data, '{email}', (SELECT '"' || user_email || '"')::jsonb)
    WHERE user_id = generated_user_id;

END;
$$ language plpgsql;

CREATE TABLE products
(
    id          bigint generated by default as identity primary key,
    title       text,
    description text,
    rarity      varchar(30),
    set         text,
    card_type   varchar(30),
    attributes  varchar(100),
    types       varchar(100),
    price       float,
    created_at  timestamp with time zone default timezone('utc'::text, now()) not null
);

alter table products
    enable row level security;

create
    policy "Logged in users can create products." on products for
    insert with check (true);

create
    policy "Logged in users can update products." on products for
    update using (true);

create
    policy "Logged in users can delete products." on products for
    delete
    using (true);

create
    policy "products are public." on products for
    select using (true);


CREATE TABLE payment
(
    id bigint generated by default as identity primary key,
    payment_amount float not null,
    payment_type varchar(30)
);


alter table payment
    enable row level security;

create
    policy "Logged in users can create payments." on payment for
    insert with check (true);

create
    policy "Logged in users can update payments" on payment for
    update using (true);

create
    policy "Logged in users can delete payments." on payment for
    delete
    using (true);

create
    policy "payments are public." on payment for
    select using (true);

CREATE TABLE addresses
(
    id bigint generated by default as identity primary key,
    firstname TEXT NOT NULL,
    name TEXT NOT NULL,
    company TEXT,
    "address" TEXT NOT NULL,
    zip_code TEXT NOT NULL,
    city TEXT NOT NULL
);

alter table addresses
    enable row level security;

create
    policy "Everyone can create addresses" on addresses for
    insert with check (true);

create
    policy "Logged in admins can update addresses" on addresses for
    update using (true);

create
    policy "Logged in admins can delete addresses" on addresses for
    delete using (true);

create
    policy "Logged in admins can read addresses" on addresses for
    select using (true);

CREATE TABLE customer
(
    id bigint generated by default as identity primary key,
    email TEXT NOT NULL,
    shipping_address_id bigint REFERENCES addresses(id) NOT NULL,
    billing_address_id bigint REFERENCES addresses(id) NOT NULL
);

alter table customer
    enable row level security;

create
    policy "Everyone can create customers" on customer for
    insert with check (true);

create
    policy "Logged in admins can update customer data" on customer for
    update using (true);

create
    policy "Logged in admins can delete customer accounts" on customer for
    delete using (true);

create
    policy "Logged in admins can read customer orders" on customer for
    select using (true);


CREATE TABLE orders
(
    id bigint generated by default as identity primary key,
    order_state varchar(30),
    payment_id bigint references payment(id),
    customer_id bigint references customer(id),
    notification_sent BOOLEAN default false
);


alter table orders
    enable row level security;

create
    policy "Everyone can create orders." on orders for
    insert with check (true);

create
    policy "Logged in users can update orders." on orders for
    update using (true);

create
    policy "Logged in users can delete orders." on orders for
    delete
    using (true);

create
    policy "orders are public." on orders for
    select using (true);



CREATE TABLE orderitem
(
    id bigint generated by default as identity primary key,
    order_id bigint references orders(id),
    product_id bigint references products(id),
    quantity INT default 1
);

alter table orderitem
    enable row level security;

create
    policy "Everyone can create orderitems." on orderitem for
    insert with check (true);

create
    policy "Logged in users can update orderitems" on orderitem for
    update using (true);

create
    policy "Logged in users can delete orderitems." on orderitem for
    delete
    using (true);

create
    policy "orderitems are public." on orderitem for
    select using (true);



